function [fs,B] = evaluate_integrands(ang,Xs,col)
% Inputs:
% ang = 1 x n_int vector of angles in [0,2*pi) that defines the set of 
%       n_int different integrand(s) to be evaluated
% Xs = a cell array, each element of which contains evaluation points for the
%       specific integrand as column vectors
% col = number in {1,2,3} controlling which RGB channel is used
% Outputs:
% f = n_int x n array
% f(i,j) = evaluation of the ith integrand on the jth point
% B = n_int x n_int covariance matrix
% B(i,j) = exp( < omega_o(:,i) , omega_o(:,j) > - 1 )

% define the collection of integrands
% these are indexed by a vector omega_o in S^2, representing the viewing 
% angle of the observer
n_int = length(ang); % number of integrands
if sum((ang<0) + (ang >= 2*pi)) > 0
    error('Angles must be in [0,2*pi).')
end
omega_o = zeros(3,n_int); 
azimuth = 0; % in [0,2pi]
elevation = ang; % in [0,2pi]
for i = 1:n_int
    [x,y,z] = sph2cart(azimuth,elevation(i),1); % direction to look in
    omega_o(:,i) = [x,y,z]';
end

% compute the covariance matrix B
% this uses the same covariance function as in Xi et al, ICML 2018
B = zeros(n_int,n_int);
for i = 1:n_int
    for j = 1:n_int
        B(i,j) = exp(omega_o(:,i)' * omega_o(:,j) - 1);
    end
end

% find out the total number of evaluation points
ns = zeros(1,n_int);
for i = 1:n_int
  ns(i) = size(Xs{i},2);
end

% load an environment map
envMap = hdrread('envMaps/Mono_Lake_B_Env.hdr');

% evaluate integrand(s)
fs = {};
for i = 1:n_int % the ith integrand
    X = Xs{i};
    f = zeros(ns(i),1);
    for j = 1:ns(i) % the jth point
        omega_i = X(:,j);
        fval = integrand(omega_i,omega_o(:,i),envMap);
        f(j) = fval(col); % read off the desired color channel
    end
    fs{i} = f;
end

end





