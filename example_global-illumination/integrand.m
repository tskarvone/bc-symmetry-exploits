% Evaluates f(x); our job is to integrate f(x) uniformly over S^2.
% Inputs:
% an "incident direction" omega_i (a 3D vector on S^2) 
% an "outgoing direction" omega_o (a 3D vector on S^2)
% an environment map
% Output:
% fval has three numbers; one each for red, green and blue

% This example comes from "A Spherical Gaussian Framework for Bayesian 
% Monte Carlo Rendering of Glossy Surfaces" by Marques et al.

% Background, from Ricardo Marques:
% "Roughly speaking, you can think about k_s as the attenuation that light
% suffers when reflected at a surface. The simplest thing to do is to take
% a value k_s such that the integral of Eq. (19) over the hemisphere equals 1,
% in which case there is no attenuation.
% As for the w = 1 / sqrt( m )  (see text under Eq. (20)), the most common is 
% to reason in terms of m. In the article we took m = 20, 50 and 80, which are 
% typical representative values used in rendering. However, if it serves better
% your interests, any values between 1 and 100 seem sensible to me."

function fval = integrand(omega_i,omega_o,envMap)

if (omega_i * omega_o') <= 0 % there is no contribution from the "lower hemisphere"
    fval = zeros(3,1);
else

    n = omega_o; % normal to the sphere at omega_0. 
                 % assumes that "the lobe central axis is aligned with the surface normal"
    Li = querryEM(envMap,omega_i); % the "incident radiance"

    m = 1; % Ricardo recommends m between 1 and 100
    ks = 1/(2*pi); % the "specular coefficient". 
                   % Ricardo recommends taking ks such that Eqn. 19 in (*) 
                   % integrates to (at most) one
                   % (*) A Spherical Gaussian Framework for Bayesian Monte 
                   % Carlo Rendering of Glossy Surfaces
                   % The choice 1/(2*pi) means that Eqn. 19 integrates to 
                   % something less than one.
    w = 1/sqrt(m); % the "lobe sharpness"
    omega_r = 2 * (omega_o * n') * n - omega_o; % the "lobe axis direction"
    rho = ks * exp((omega_r * omega_i' - 1) / w^2); % the "bidirectional scattering 
                                                    % distribution function (BDRF)"

    fval = Li * rho * (omega_i' * n);

end

end
