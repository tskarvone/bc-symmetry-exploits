%%%%%%%%%
%%%
%%%  EXAMPLE 2:
%%%   Computation of global illumination integrals using
%%%   fully symmetric multi-output Bayesian cubature.
%%%
%%% Toni Karvonen, 2018
%%%
%%%%%%%%%

  clear all
  close all

  % Addpaths
  addpath('../functions/')
  
  % Basic integrand parameters 
  load 'ref_ints.mat'
  inds      = 1:50;
  col       = 3; % Color channel, either 1, 2 or 3
  J         = 6; % Number of fully symmetric sets per integrand
  ang       = ang(inds);
  ref_ints  = ref_ints(inds,col);
  D_tot     = length(ang);
  
  % Kernel
  k  = @(r) 8/3 - r; % Need this in isotropic form
  km = @(x) 4/3;
  kmm = 4/3;
  isotropic = true;
  
  % Do a number of Monte Carlo runs
  N_MC = 100; % Number of Monte Carlo runs
  mean_rel_errs = zeros(D_tot,N_MC);
  max_rel_errs = zeros(D_tot,N_MC);
  rel_errs_BMC = zeros(D_tot,N_MC);
    
  for N = 1:N_MC
    % Space for saving stuff
    uss = {};
    UDs = {};
    Xs  = {};
    rel_errs_BMC_N = zeros(1,D_tot);
    
    % Model different numbers of integrands simultaneously
    for r = 1:D_tot
    
      % Parameters for this r
      ds      = 1:r;
      ang_d   = ang(ds);
      D       = length(ang_d);
      
      % Generate random samples on S^2 to be used as generator vectors
      tmp = randn(3,J);
      uss{r} = tmp./sqrt(sum(tmp.^2));
      Us = fss_gen(uss{r},3);
      UDs{r} = Us;
      Xs{r} = cell2mat(Us);
      
      % Compute integral estimates using fully symmetric multi-output BC
      [Ys,B] = evaluate_integrands(ang_d,Xs,col);
      Y = cell2mat(Ys');  
      same = false;
      [mus_ds, vs, W, W_uniq] = bc_multi_separable_fss(k, km, kmm, B, UDs, Y, same, isotropic);
      MUs(ds,r) = mus_ds;
      
      % Compute integral estimates using regular Bayesian Monte Carlo
      tmp = randn(3,48*J);
      X_BMC = tmp./sqrt(sum(tmp.^2));
      Y_BMC = evaluate_integrands(ang(r),{X_BMC},col);
      Y_BMC = cell2mat(Y_BMC);
      mu_BMC = kq(Y_BMC, X_BMC, k, km, kmm, isotropic);
      rel_errs_BMC_N(r) = abs((ref_ints(r)-mu_BMC)/ref_ints(r));
      
      % Print progress
      fprintf('PROGRESS: D = %i/%i; MC run = %i/%i\n', r, D_tot, N, N_MC);
      
    end

    % Compute relative erros for this Monte Carlo run
    rel_errs_N = zeros(D_tot,D_tot);
    mean_rel_errs_N = zeros(D_tot,1);
    max_rel_errs_N = zeros(D_tot,1);
    for d = 1:D_tot
      rel_errs_N(1:d,d) = abs((ref_ints(1:d)-MUs(1:d,d))./ref_ints(1:d));
      mean_rel_errs_N(d) = mean( rel_errs_N(1:d,d) );
      max_rel_errs_N(d) = max(rel_errs_N(1:d,d));
    end
    
    % Save everything necessary
    mean_rel_errs(inds,N) = mean_rel_errs_N;
    max_rel_errs(inds,N) = max_rel_errs_N;
    rel_errs_BMC(inds,N) = rel_errs_BMC_N;
    
  end
  
  mean2_rel_errs = mean(mean_rel_errs,2);
  max2_rel_errs = mean(max_rel_errs,2);
  rel_errs_BMC_mean = mean(rel_errs_BMC,2);

  
  % Plot
  semilogy(inds,mean2_rel_errs,inds,max2_rel_errs,inds,rel_errs_BMC_mean,'x','LineWidth',1.5)
  legend('Mean relative error', 'Maximum relative error','BMC')
  xlabel('D (number of integrands)')
  
