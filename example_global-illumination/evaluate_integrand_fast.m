function f = evaluate_integrand_fast(ang,X,col)
% This is a fast and dirty function for evaluating an illumination integrand
% specified by the angle ang (in [0,2pi)) and color channel col (=1,2,3)
% at points X(:,i), i = 1,...,N.
%
% The function is only used by the script reference_integrals.m

  if sum((ang<0) + (ang >= 2*pi)) > 0
      error('Angles must be in [0,2*pi).')
  end
  azimuth = 0; % in [0,2pi]
  [xx,yy,zz] = sph2cart(azimuth,ang,1);
  omega_o = [xx,yy,zz]';
  omega_r = 2 * (omega_o * omega_o') * omega_o - omega_o; % the "lobe axis direction"
  
  % load an environment map
  envMap = hdrread('envMaps/Mono_Lake_B_Env.hdr');
  [mapHeigh, mapWidth] = size(envMap);
  
  % evaluate the integrand
  N = size(X,2);
  f = zeros(N,1);
  for i = 1:N
    omega_i = X(:,i);
    if (omega_i * omega_o') <= 0 % there is no contribution from the "lower hemisphere"
        fval = zeros(3,1);
    else
        x = 1 + ((mapWidth/3-1)*(0.5 * (1.0 + atan2(-omega_i(1), -omega_i(3)) / pi)));
        %y = 1 + ((mapHeigh-1)*(acos( clamp(omega_i(2), -1.0, 1.0) ) / pi));
        y = 1 + ((mapHeigh-1)*(acos( max(-1.0,min(omega_i(2),1.0)) ) / pi));
        x = round(x);
        y = round(y);
        Li = reshape(envMap(y, x, :), 1, 3);
        rho = (1/(2*pi)) * exp((omega_r * omega_i' - 1)); % the "bidirectional scattering 
        fval = Li * rho * (omega_i' * omega_o);
    end
    f(i) = fval(col); % read off the desired color channel
  end
  
end
