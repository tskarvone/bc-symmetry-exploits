function [mu, s, wkr, wpr] = bsc_fss(Y, Us, k, kmean, Ikmean, m, dist, isotropic)
% BSC_FSS - fully symmetric Bayes-Sard cubature
%
%   Computes fully symmetric Bayes-Sard cubature mean and variance using Theorem 2 in
%     
%     Karvonen, Särkkä, Oates (2018). Symmetry exploits for Bayesian cubature methods.
%
%   The evaluation points are given as cell array Us, each element of which is a matrix
%   whose columns constitute a fully symmetric set generated by a vector. The function
%   evaluations are provided in a column vector Y.   
%
% INPUT
%   - Y           a row vector of function evaluation at points of Us
%   - Us          a cell array of FSSs with columns being the nodes
%   - k           kernel, given as k(r) if isotropic or k(x,y) if not
%   - kmean       kernel mean, given as kmean(x)
%   - Ikmean      integrated kernel mean (i.e. initial WCE)
%   - m           degree of the polynomial space pi (must have dim(pi) <= n)
%   - dist        integration distribution, options:
%                   'uniform' - uniform distribution on the hypercube [0,1]^d (default input)
%                   'normal'  - standard Gaussian distribution on R^d
%   - isotropic   TRUE for isotropic (default), FALSE for not isotropic
%
% OUTPUT
%   - mu          FSS-BSC posterior mean
%   - s           FSS-BSC posterior variance
%   - wkr         column vector w_Lambda^k of the unique weights corresponding to kernel translates
%   - wpr         column vector w_A^pi of the unique weights corresponding to polynomial basis functions

% Toni Karvonen, 2017

  % Argument checks
  if ~exist('dist', 'var')
    dist = 'uniform';
  end

  if ~exist('isotropic', 'var')
    isotropic = true;
  end

  % Call a function to generate a number of necessary objects
  [wkr, wpr, wr, kmvr, Ipr, Lsa, B] = bsw_fss(Us, k, kmean, m, dist, isotropic);
  
  % Compute the FSS-BSC mean
  mu = 0;
  J = length(wkr);
  Ja = length(wpr);
  Ls = zeros(J,1);
  ind = 0;
  for i = 1:J
    Ls(i) = size(Us{i}, 2);
    mu = mu + wkr(i) * sum(Y(ind+1:ind+Ls(i)));
    ind = ind + Ls(i);
  end
  
  % Compute the integral posterior variance
  s = Ikmean - wr' * (Ls .* kmvr) + (wpr .* Lsa)' * (B*wr  - Ipr);
    
end
