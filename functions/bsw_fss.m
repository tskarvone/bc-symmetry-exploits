function [wkr, wpr, wr, kmvr, Ipr, Lsa, B] = bsw_fss(Us, k, kmean, m, dist, isotropic)
% BSW_FSS - compute fully symmetric Bayes-Sard weights and other quantities
%
%   Computes a number of quantities needed in fully symmetric Bayes-Sard cubature.
%   The computations are based on Theorem 2 in 
%     
%     Karvonen, Särkkä, Oates (2018). Symmetry exploits for Bayesian cubature methods.
%
% INPUT
%   - Us            a cell array of FSSs with columns being the nodes
%   - k             kernel, given as k(r) if isotropic or k(x,y) if not
%   - kmean         kernel mean, given as kmean(x)
%   - m             degree of the polynomial space pi (must have dim(pi) <= n)
%   - dist          integration distribution, options:
%                     'uniform' - uniform distribution on the hypercube [0,1]^d (default input)
%                     'normal'  - standard Gaussian distribution on R^d
%   - isotropic     TRUE for isotropic (default), FALSE for not isotropic
%
% OUTPUT
%   - wkr           unique weights w_Lambda^k corresponding to kernel translates
%   - wpr           unique weights w_A^pi corresponding to even monomial basis functions
%   - wr            unique weights w_Lambda^sigma of the standard Bayesian cubature (needed for BSC variance)
%   - kmvr          kernel mean evaluations at the generator vectors
%   - Ipr           integrals of x^(alpha_i) for even multi-indices alpha_i
%   - Lsa           sizes of of the positive fully symmetric sets [alpha_i]^+ 
%   - B             transpose of the matrix B in Thm. 2 (needed for BSC variance)

% Toni Karvonen, 2018
  
  % Argument checks
  if ~exist('dist', 'var')
    dist = 'uniform';
  end

  if ~exist('isotropic', 'var')
    isotropic = true;
  end

  % Define functions for computing the monomial integrals.
  %   This function must return an integral given a column
  %   vector representing a monomial.
  if strcmp(dist, 'uniform')
    % int_0^1 x^p = 1/(p+1)
    intf = @(p) prod(( 1./(p+1) ));
  elseif strcmp(dist, 'normal')
    % The first term is 0 if any power is odd, whereas the second
    % contains the product of odd standard Gaussian moments.
    intf = @(p) 0^(sum(mod(p,2)==1)) * prod( factorial(p)./(2.^round(p/2).*factorial(round(p/2))) );
  else
    error('Supplied distribution (argument: dist) not recognised.')
  end  
  
  % Save some basic parameters
  J = length(Us);
  d = size(Us{1},1);  
    
  % Form the matrix S containing row sums between
  % different fully symmetric sets and the vector
  % kmvr of kernel mean evaluations at norms of 
  % each generator.
  S    = fss_rsmat(Us, k, isotropic);
  kmvr = zeros(J, 1);
  for j = 1:J
    kmvr(j) = kmean(Us{j}(:,1));
  end
  
  % Form the Vandermonde matrix of even polynomials
  % and a vector of their integrals
  
  
  %%%% Form the reduced Vandermonde matrices
    
    A     = [];
    B     = [];
    Lsa    = [];
    Lsa(1) = 1;
    Ipr    = [];
    Ipr(1) = 1;
    for j = 1:J
      A(j,1) = 1;
      B(1,j) = size(Us{j},2);
    end
    
    ind = 2;
    for l = 2:2:floor(m)
      % For each l = 1,...,m, 'parts' is a matrix whose rows are
      % all possible ways of summing d non-negative integers to l.      
      if l > 4
        % if l is "large", use a general piece of code that is 
        % EXTREMELY SLOW if d is large
        [~,parts] = nsumk(d,l);               
        parts = unique(sort(parts,2),'rows');
      else
        % if l is small, just do it manually
        if l == 2
          parts = [2 zeros(1,d-1)];
        elseif l == 4
          parts = [2 2 zeros(1,d-2); 4 zeros(1,d-1)];        
        end
      end
      % Loop over monomial powers
      for p = 1:size(parts,1)
        pol = parts(p,:)';
        if sum(mod(pol,2)) == 0
          uperms = uperm(parts(p,:))';
          Lsa = [Lsa; size(uperms, 2)];
          for j = 1:J
            tmpA = 0;
            tmpB = 0;
            U = Us{j};
            for i = 1:size(U,2);
              tmpB = tmpB + prod(U(:,i).^pol);
            end
            for u = 1:size(uperms,2)
              pol2 = uperms(:,u);
              X = Us{j}(:,1);
              tmpA = tmpA + prod(X.^pol2);
            end
            A(j,ind) = tmpA;
            B(ind,j) = tmpB;
          end
          Ipr(ind) = intf(pol);
          ind = ind + 1;
        end
        
      end
      
    end
    Ipr = Ipr(:);
    
  %%%% Solve the unique weights
    
    wr = S\kmvr;  
    SP = [S A; B zeros(size(B,1),size(B,1))];
    Ikp = [kmvr; Ipr];
    w = SP\Ikp;
    wkr = w(1:J);
    wpr = w(J+1:end);
     
end

% The following auxiliary function constructs indices of unique permutations
% of elements of the given vector. Taken from (the answer by Bruno):
% https://se.mathworks.com/matlabcentral/newsreader/view_thread/164470
function p = uperm(a)
  [u, ~, J] = unique(a);
  n = length(a);
  
  ktab = histc(J,1:max(J));
  l = n;
  p = zeros(1, n);
  s = 1;
  for i=1:length(ktab)
      k = ktab(i);
      c = nchoosek(1:l, k);
      m = size(c,1);
      [t, ~] = find(~p.');
      t = reshape(t, [], s);
      c = t(c,:)';
      s = s*m;
      r = repmat((1:s)',[1 k]);
      q = accumarray([r(:) c(:)], i, [s n]);
      p = repmat(p, [m 1]) + q;
      l = l - k;
  end
  
  p = u(p);
end
