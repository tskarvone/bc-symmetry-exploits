function [mus, vs, W, W_uniq] = bc_multi_separable_fss(k, km, kmm, B, UDs, Y, same, isotropic)
% BC_MULTI_SEPARABLE_FSS - Separable multi-output Bayesian cubature with fully symmetric sets
%
%   Computes integrals of D related functions, evaluated on fully symmetric point sets,
%   using a separable multi-output kernel and the methods from
%
%     Xi, Briol, Girolami (2018). Bayesian Quadrature for Multiple Related Integrals. ICML 2018.
%   
%   and
%
%     Karvonen, Särkkä, Oates (2018). Symmetry exploits for Bayesian cubature methods.
%
%   The multi-output kernel is assumed to take the form k_mo(x,y) = B*k(x,y) for a (D x D) matrix B
%   and a scalar-output positive-definite kernel k(x,y).
%
% INPUT
%   - k           Scalar-output kernel. Given two vectors x and y, k(x,y) returns a scalar.
%   - km          Scalar-output kernel mean. Given a vector x, returns a scalar.
%   - kmm         Integral of the kernel mean, scalar.
%   - UDs         A D-dimensional cell array, d-th element of which is a cell array containing
%                 fully symmetric sets that constitute the evaluation points for the d-th integrand.
%   - B           A (D x D) positive-definite matrix representing output covariance.
%   - Y           A column vector of integrand evaluations, ordered to be "compatible"
%                 with UDs.
%   - same        TRUE if same points are used for each integrand, FALSE otherwise.
%                 DEFAULT: FALSE
%   - isotropic   TRUE for isotropic (default), FALSE for not isotropic
%
% OUTPUT
%   - mus         Estimates of the D integrals, (D x 1) matrix.
%   - vs          Integral variance, (D x D) matrix.
%   - W           The multi-output Bayesian cubature weights, (N_total x D) matrix,
%                 N_total being the total number of evaluation points in Xs.
%   - W_uniq      Matrix of the unique multi-output weights.

% Toni Karvonen, 2018

  D = size(B,1);

  if ~exist('same', 'var')
    same = false;
  end

  if ~exist('isotropic', 'var')
    isotropic = false;
  end

  %%%%% If the same evaluation points are used for each integrand, we can exploit
  %%%%% Kronecker products.
  if same
    
    Us = UDs{1};                % All the FSSs are the same
    J = length(Us);             % Number of FSSs
    N  = size(cell2mat(Us),2);  % Number of points
    
    % Solve the distinct weights
    S  = fss_rsmat(Us, k, isotropic);
    kmv_uniq = zeros(J, 1);
    for j = 1:J
      kmv_uniq(j) = km(Us{j}(:,1));
    end
    w_uniq = S\kmv_uniq;
    
    % Produce the full weight matrix
    w   = zeros(N,1);
    kmv = zeros(N,1);
    ind = 0;
    for j = 1:J
      Nj = size(Us{j},2);
      w(ind+1:ind+Nj) = w_uniq(j)*ones(Nj,1);
      kmv(ind+1:ind+Nj) = kmv_uniq(j)*ones(Nj,1);
      ind = ind + Nj;
    end
    
    % Compute integral estimates etc.
    W = kron(eye(D), w);
    mus = W'*Y;
    vs  = B*kmm - W'*kron(B,kmv);
  
  %%%%% If the points sets are distinct, we have to it the hard way.  
  else
    
    % Total number of fully symmetric sets
    Js = zeros(D,1); 
    for n = 1:D
      Js(n) = length(UDs{n});
    end
    J_tot = sum(Js);
    
    % Form the reduced row-sum version of all the necessary matrices
    % and solve the unique weights
    S = zeros(J_tot, J_tot);
    kmv_uniq = zeros(J_tot, 1);
    for n = 1:D
      for m = 1:D
        % Row-sum kernel matrix for this pair of dimensions
        J1 = Js(n);
        J2 = Js(m);
        S_sub = zeros(J1, J2);
        kmv_uni_sub = zeros(J1);
        % Compute efficiently if the kernel is isotropic
        if isotropic
          for nn = 1:J1
            x = UDs{n}{nn}(:,1);
            kmv_uniq_sub(nn) = km(UDs{n}{nn}(:,1));
            for mm = 1:J2
              U = UDs{m}{mm};
              S_sub(nn,mm) = sum( k( sqrt(sum( (repmat(x,1,size(U,2))-U).^2)) ) );
            end
          end
        % Compute less efficiently if the kernel is not isotropic...
        else
          for nn = 1:J1
            x = UDs{n}{nn}(:,1);
            kmv_uniq_sub(nn) = km(UDs{n}{nn}(:,1));
            for mm = 1:J2
              U = UDs{m}{mm};
              foo = 0;
              for p = 1:size(U,2)
                foo = foo + k(x,U(:,p));
              end
              S_sub(nn,mm) = foo;
            end
          end
        end
        % Allocate a block of S
        S(sum(Js(1:n-1))+1:sum(Js(1:n)), sum(Js(1:m-1))+1:sum(Js(1:m))) = B(n,m)*S_sub;
        kmv_uniq(sum(Js(1:n-1))+1:sum(Js(1:n)), m) = B(n,m)*kmv_uniq_sub;
        
      end
    end
    W_uniq = S\kmv_uniq;
    
    % Generate the full weight matrix
    N_tot = length(Y);
    W = zeros(N_tot, D);
    kmv = zeros(N_tot, D);
    for m = 1:D
      indL = 0;
      indW = 1;
      for mm = 1:D
        for n = 1:Js(mm)
          L = size(UDs{mm}{n}, 2);
          W(indL+1:indL+L, m) = W_uniq(indW,m)*ones(L,1);
          kmv(indL+1:indL+L, m) = kmv_uniq(indW,m)*ones(L,1);
          indL = indL + L;
          indW = indW + 1;
        end
      end
    end
    
    % Compute the integral estimates etc.
    mus = W'*Y;
    vs  = B*kmm - W'*kmv;
        
  end
  
end
