function [P Ip] = vandermonde(m, X, dist)
% VANDERMONDE - construct the Vandermonde matrix
%
%   Given an d X n matrix X, each column of which represents
%   one evaluation point, this function constructs the n X Q 
%   Vandermonde matrix
%
%     [P]_ij = p_j(x_i)
%
%   for the space pi_m, spanned by monomials p_j, of polynomials 
%   having total (absolute) degree at most m, and the vector
%
%     [Ip]_i = int p_i(x) dist(x) dx
%   
%   of integrals of these monomials w.r.t. the given distribution.
%
% INPUT
%   - m     total degree of the polynomials space
%   - X     input points in a matrix, each column is one point
%   - dist  integration distribution, options:
%               'uniform' - uniform distribution on the hypercube [0,1]^d (default input)
%               'normal'  - standard Gaussian distribution on R^d
% OUTPUT
%   - P   the n X Q Vandermonde matrix [P]_ij = p_j(x_i)
%   - Ip  the Q x 1 vector of integrals [Ip]_i = int p_i(x) dist(x) dx

% Toni Karvonen, 2018
  
  if ~exist('dist', 'var')
    dist = 'uniform';
  end
  
  % Save some relevant quantities
  d = size(X,1);          % Space dimension
  n = size(X,2);          % Number of points
  Q = nchoosek(m+d,d);    % Polynomial space dimension
  
  % Define functions for computing the monomial integrals.
  %   This function must return an integral given a column
  %   vector representing a monomial.
  
  if strcmp(dist, 'uniform')
    % int_0^1 x^p = 1/(p+1)
    intf = @(p) prod(( 1./(p+1) ));
  elseif strcmp(dist, 'normal')
    % The first term is 0 if any power is odd, whereas the second
    % contains the product of odd standard Gaussian moments.
    intf = @(p) 0^(sum(mod(p,2)==1)) * prod( factorial(p)./(2.^round(p/2).*factorial(round(p/2))) );
  else
    error('Supplied distribution (argument: dist) not recognised.')
  end
  
  % Construct the n X Q Vandermonde matrix and the Q x 1 integral vector Ip.
  %   This happens as follow:
  %   For each l = 1,...,m, 'parts' is a matrix whose rows are
  %   all possible ways of summing d non-negative integers to l.
  %   For each of these possibilities, 'uperms' is a matrix
  %   whose columns are all possible (unique) permutations of the
  %   integers. Each of these columns corresponds to a monomial
  %   basis polynomial of pi_m, so we compute the value of
  %   this polynomial at each data point and add a new 
  %   column to the Vandermonde matrix P. The corresponding
  %   integral for Ip is easy to compute.

  P = zeros(n,Q);
  Ip = zeros(Q,1);
  P(:,1) = 1;
  Ip(1) = 1;
    
  % If d = 1, use a simpler alternative
  if d == 1
    for l = 1:m
      P(:,l+1) = (X.^l)';
      Ip(l+1)  = intf(l);
    end
  % Otherwise do more complicated things as outlined above
  else
    indP = 2;
    indIp = 2;
    for l = 1:m
      [~,parts] = nsumk(d,l);
      parts = unique(sort(parts,2),'rows');
      for p = 1:size(parts,1)
        uperms = uperm(parts(p,:))';
        Nuperms = size(uperms,2);
        Ip(indIp:indIp+Nuperms-1) = intf(parts(p,:)');
        indIp = indIp + Nuperms;
        for u = 1:Nuperms
          pol = uperms(:,u);
          P(:,indP) = prod(X.^repmat(pol,1,n))'; % In high dimensions, this is the slowest part
          indP = indP + 1;
        end
      end
    end
  end
  
end

% The following auxiliary function constructs indices of unique permutations
% of elements of the given vector. Taken from (the answer by Bruno):
% https://se.mathworks.com/matlabcentral/newsreader/view_thread/164470
function p = uperm(a)
  [u, ~, J] = unique(a);
  n = length(a);
  
  ktab = histc(J,1:max(J));
  l = n;
  p = zeros(1, n);
  s = 1;
  for i=1:length(ktab)
      k = ktab(i);
      c = nchoosek(1:l, k);
      m = size(c,1);
      [t, ~] = find(~p.');
      t = reshape(t, [], s);
      c = t(c,:)';
      s = s*m;
      r = repmat((1:s)',[1 k]);
      q = accumarray([r(:) c(:)], i, [s n]);
      p = repmat(p, [m 1]) + q;
      l = l - k;
  end
  
  p = u(p);
end
