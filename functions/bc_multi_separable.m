function [mus, vs, W] = bc_multi_separable(k, km, kmm, B, Xs, Y, same)
% BC_MULTI_SEPARABLE - Separable multi-output Bayesian cubature
%
%   Computes integrals of D related functions using a separable multi-output kernel and the
%   method from
%
%     Xi, Briol, Girolami (2018). Bayesian Quadrature for Multiple Related Integrals. ICML 2018.
%   
%   The multi-output kernel is assumed to take the form k_mo(x,y) = B*k(x,y) for a (D x D) matrix B
%   and a scalar-output positive-definite kernel k(x,y).
%
% INPUT
%   - k         Scalar-output kernel. Given two vectors x and y, k(x,y) returns a scalar.
%   - km        Scalar-output kernel mean. Given a vector x, returns a scalar.
%   - kmm       Integral of the kernel mean, scalar.
%   - Xs        A cell array of evaluation points for each of the D integrands.
%               Xs{d}(:,i) must be the i-th evaluation point for the d-th integrand.
%   - B         A (D x D) positive-definite matrix representing output covariance.
%   - Y         A column vector of integrand evaluations, ordered to be "compatible"
%               with Xs.
%   - same      TRUE if same points are used for each integrand, FALSE otherwise.
%               DEFAULT: FALSE
%
% OUTPUT
%   - mus       Estimates of the D integrals, (D x 1) matrix.
%   - vs        Integral variance, (D x D) matrix.
%   - W         The multi-output Bayesian cubature weights, (N_total x D) matrix,
%               N_total being the total number of evaluation points in Xs.

% Toni Karvonen, 2018

  D = length(Xs);

  if ~exist('same', 'var')
    same = false;
  end

  %%%%% If the same evaluation points are used for each integrand, we can exploit
  %%%%% Kronecker products.
  if same
  
    X = Xs{1};
    N = size(X,2);
    
    K   = zeros(N, N);
    kmv = zeros(N, 1);
    for n = 1:N
      for m = n:N
        tmp = k(X(:,n),X(:,m));
        K(n,m) = tmp;
        K(m,n) = tmp;
      end
      kmv(n) = km(X(:,n));
    end
    
    w   = K\kmv;
    W   = kron(eye(D), w);
    mus = W'*Y;
    vs  = B*kmm - W'*kron(B,kmv);
    
  %%%%% If the points sets are distinct, we have to it the hard way.
  else
  
    Ns = zeros(1,D);
    for n = 1:D
      Ns(n) = size(Xs{n},2);
    end
    N_sum = sum(Ns);
    
    K   = zeros(N_sum, N_sum);
    kmv = zeros(N_sum, D);
    for n = 1:D
      N1 = Ns(n);
      for m = 1:D
        N2 = Ns(m);
        K_sub   = zeros(N1,N2);
        kmv_sub = zeros(N1,1);
        for nn = 1:N1
          kmv_sub(nn) = km(Xs{n}(:,nn));
          for mm = 1:N2
            K_sub(nn,mm) = k(Xs{n}(:,nn), Xs{m}(:,mm));
          end
        end
        K(sum(Ns(1:n-1))+1:sum(Ns(1:n)), sum(Ns(1:m-1))+1:sum(Ns(1:m))) = B(n,m)*K_sub;
        kmv(sum(Ns(1:n-1))+1:sum(Ns(1:n)), m) = B(n,m)*kmv_sub;
      end
    end
    
    % Solve the weight matrix and compute the integral estimates and their variance
    W   = K\kmv;
    mus = W'*Y;
    vs  = kmm - W'*kmv;
  end
  
end
